import motor.motor_asyncio
import db_parameters


def write_data_from_csv(data_type, **kwargs):
    pass


def write_one_document(data_type, **kwargs):
    pass


class DBWriter:
    """
    MongoDB database writer; uses asynchronous query mechanism in "motor" package by default.
    """

    def __init__(self, host, port, username, password, database_name,
                 server_id, process_name, process_id, session_config_id):
        """
        :param host: Database connection host name.
        :param port: Database connection port number.
        :param username: Database authentication username.
        :param password: Database authentication password.
        :param database_name: Name of database to connect to (do not confuse with collection name).
        :param server_id: ID value for the server this writer is running on.
        :param process_name: Name of the process this writer is attached to (writing from).
        :param process_id: ID value for the process this writer is attached to (writing from).
        :param session_config_id: Configuration ID value that was assigned to this run/session of data processing.
        """
        self.host, self.port = host, port
        self.username, self.password = username, password
        self.db_name = database_name
        self.server_id = server_id
        self.process_name = process_name
        self.process_id = process_id
        self.session_config_id = session_config_id

        # Connect immediately upon instantiation.
        # TODO: consider adding a PyMongo version as well for one-off writes
        # TODO: figure out if there are resiliency checks that we can do for async writes -- callbacks?
        self.client = motor.motor_asyncio.AsyncIOMotorClient(host=self.host, port=self.port,
                                                             username=self.username, password=self.password)
        self.db = self.client[database_name]

    def __del__(self):
        """
        Upon DBReader deletion, close the client/connection.
        :return: None
        """
        try:
            self.client.close()
        # TODO: add the motor exception that would be raised
        except:
            pass

    def write_trajectory_fragment(self, local_fragment_id: int, coarse_vehicle_class: int, fine_vehicle_class: int,
                                  timestamps: list[float], raw_timestamps: list[float], road_segment_id: int,
                                  x_positions: list[float], y_positions: list[float],
                                  lengths: list[float], widths: list[float], heights: list[float],
                                  direction: int, flags: list[str] = None, camera_snapshots: list[bytes] = None):
        """
        Write a raw trajectory according to the data schema, found here:
            https://docs.google.com/document/d/1xli3N-FCvIYhvg7HqaQSOcKY44B6ZktGHgcsRkjf7Vg/edit?usp=sharing
        Values that are in the schema, but assigned by the database are: db_write_timestamp, _id.
        Values that are in the schema, but calculated implicitly from others are: first_timestamp, last_timestamp,
            starting_x, ending_x.
        Values that are in the schema, but given to DBWriter at instantiation are: configuration_id, compute_node_id.
        :param local_fragment_id: Integer unique to each tracked vehicle per compute_node_ID and configuration_ID,
            generated by the tracker
        :param coarse_vehicle_class: Vehicle coarse class number
        :param fine_vehicle_class: Vehicle fine class number
        :param timestamps: Array of corrected timestamps; may be corrected to reduce timestamp errors.
        :param raw_timestamps: Raw timestamps from video frames as reported by the camera, may contain bias or errors.
        :param road_segment_id: Unique road segment ID; differentiates mainline from ramps.
        :param x_positions: Array of back-center x-position along the road segment in feet. X=0 is beginning of segment.
        :param y_positions: Array of back-center y-position across the road segment in feet. Y=0 is located at the left
            yellow line, i.e., the left-most edge of the left-most lane of travel in each direction.
        :param lengths: Vehicle length in feet.
        :param widths: Vehicle width in feet.
        :param heights: Vehicle height in feet.
        :param direction: Indicator of roadway direction (-1 or +1).
        :param flags: List of any string flags describing the data.
        :param camera_snapshots: Possibly empty array of JPEG compressed images (as bytes) of vehicles.
        :return: None
        """
        collection_name = db_parameters.RAW_TRAJECTORY_COLLECTION
        configuration_id = self.session_config_id
        compute_node_id = self.server_id
        pass

    def write_stitch(self, vehicle_id: int, lead_vehicle_id: int, fragment_ids: list[int]):
        """
        Write a stitched trajectory reference document according to the data schema, found here:
            https://docs.google.com/document/d/1vyLgsz6y0SrpTXWZNOS5fSgMnmwCr3xD0AB6MgYWl-w/edit?usp=sharing
        Values that are in the schema, but assigned by the database are: db_write_timestamp, _id.
        Values that are in the schema, but given to DBWriter at instantiation are: configuration_id.
        :param vehicle_id: Unique vehicle ID after stitching.
        :param lead_vehicle_id: Lead vehicle ID, i.e., immediately in front of this vehicle (vehicle_id).
        :param fragment_ids: LIst of fragment IDs associated to current vehicle stitched trajectory,
            sorted by start_timestamp.
        :return: None
        """
        collection_name = ''
        configuration_id = self.session_config_id
        pass

    def write_reconciled_trajectory(self, vehicle_id: int, coarse_vehicle_class: int, fine_vehicle_class: int,
                                    timestamps: list[float], road_segment_id: int,
                                    x_positions: list[float], y_positions: list[float],
                                    length: float, width: float, height: float,
                                    direction: int, flags: list[str] = None):
        """
        Write a reconciled/post-processed trajectory according to the data schema, found here:
            https://docs.google.com/document/d/1Qh4OYOhOi1Kh-7DEwFfLx8NX8bjaFdviD2Q0GsfgR9k/edit?usp=sharing
        Values that are in the schema, but assigned by the database are: db_write_timestamp, _id
        Values that are in the schema, but calculated implicitly from others are: first_timestamp, last_timestamp,
            starting_x, ending_x.
        Values that are in the schema, but given to DBWriter at instantiation are: configuration_id.
        :param vehicle_id: Same vehicle_id assigned during stitching.
        :param coarse_vehicle_class: Vehicle coarse class number.
        :param fine_vehicle_class: Vehicle fine class number.
        :param timestamps: Corrected timestamps; may be corrected to reduce timestamp errors.
        :param road_segment_id: Unique road segment ID; differentiates mainline from ramps.
        :param x_positions: Array of back-center x-position along the road segment in feet. X=0 is beginning of segment.
        :param y_positions: Array of back-center y-position across the road segment in feet. Y=0 is located at the left
            yellow line, i.e., the left-most edge of the left-most lane of travel in each direction.
        :param length: Vehicle length in feet.
        :param width: Vehicle width in feet.
        :param height: Vehicle height in feet.
        :param direction: Indicator of roadway direction (-1 or +1).
        :param flags: List of any string flags describing the data.
        :return: None
        """
        collection_name = ''
        configuration_id = self.session_config_id
        pass

    def write_metadata(self, metadata):
        pass

    def write_ground_truth_trajectory(self, vehicle_id: int, fragment_ids: list[int], coarse_vehicle_class: int,
                                      fine_vehicle_class: int, timestamps: list[float], road_segment_id: int,
                                      x_positions: list[float], y_positions: list[float],
                                      length: float, width: float, height: float, direction: int):
        """
        Write a ground truth trajectory according to the data schema, found here:
            https://docs.google.com/document/d/1zbjPycZlGNPOwuPVtY5GkS3LvIZwMDOtL7yFc575kSw/edit?usp=sharing
        Values that are in the schema, but assigned by the database are: db_write_timestamp, _id
        Values that are in the schema, but calculated implicitly from others are: first_timestamp, last_timestamp,
            starting_x, ending_x.
        Values that are in the schema, but given to DBWriter at instantiation are: configuration_id.
        :param vehicle_id: Same vehicle_id assigned during stitching.
        :param fragment_ids: Array of fragment_id values associated to current vehicle_id.
        :param coarse_vehicle_class: Vehicle coarse class number.
        :param fine_vehicle_class: Vehicle fine class number.
        :param timestamps: Corrected timestamps; may be corrected to reduce timestamp errors.
        :param road_segment_id: Unique road segment ID; differentiates mainline from ramps.
        :param x_positions: Array of back-center x-position along the road segment in feet. X=0 is beginning of segment.
        :param y_positions: Array of back-center y-position across the road segment in feet. Y=0 is located at the left
            yellow line, i.e., the left-most edge of the left-most lane of travel in each direction.
        :param length: Vehicle length in feet.
        :param width: Vehicle width in feet.
        :param height: Vehicle height in feet.
        :param direction: Indicator of roadway direction (-1 or +1).
        :return: None
        """
        collection_name = ''
        configuration_id = self.session_config_id
        pass
